From: Andrew Johnson <anj@aps.anl.gov>
Date: Tue, 11 Mar 2014 17:12:41 -0500
Subject: libCom: Fix epicsString.h comparison functions

The string comparison functions epicsStrCaseCmp() and
epicsStrnCaseCmp() were returning incorrect results
when the strings did not match.

These functions now match their BSD equivalents, and
have working tests to confirm their operation.
---
 src/libCom/misc/epicsString.c     | 16 ++++++++--------
 src/libCom/test/epicsStringTest.c | 14 +++++++-------
 2 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/src/libCom/misc/epicsString.c b/src/libCom/misc/epicsString.c
index 907bba9..08b7089 100644
--- a/src/libCom/misc/epicsString.c
+++ b/src/libCom/misc/epicsString.c
@@ -171,11 +171,11 @@ size_t epicsStrnEscapedFromRawSize(const char *inbuf, size_t inlen)
 int epicsStrCaseCmp(const char *s1, const char *s2)
 {
     while (1) {
-        int ch1 = toupper(*s1);
-        int ch2 = toupper(*s2);
+        int ch1 = toupper((int) *s1);
+        int ch2 = toupper((int) *s2);
 
-        if (ch1 == 0) return (ch2 != 0);
-        if (ch2 == 0) return -1;
+        if (ch2 == 0) return (ch1 != 0);
+        if (ch1 == 0) return -1;
         if (ch1 < ch2) return -1;
         if (ch1 > ch2) return 1;
         s1++;
@@ -188,11 +188,11 @@ int epicsStrnCaseCmp(const char *s1, const char *s2, size_t len)
     size_t i = 0;
 
     while (i++ < len) {
-        int ch1 = toupper(*s1);
-        int ch2 = toupper(*s2);
+        int ch1 = toupper((int) *s1);
+        int ch2 = toupper((int) *s2);
 
-        if (ch1 == 0) return (ch2 != 0);
-        if (ch2 == 0) return -1;
+        if (ch2 == 0) return (ch1 != 0);
+        if (ch1 == 0) return -1;
         if (ch1 < ch2) return -1;
         if (ch1 > ch2) return 1;
         s1++;
diff --git a/src/libCom/test/epicsStringTest.c b/src/libCom/test/epicsStringTest.c
index a65365e..ea9a6fc 100644
--- a/src/libCom/test/epicsStringTest.c
+++ b/src/libCom/test/epicsStringTest.c
@@ -56,8 +56,8 @@ MAIN(epicsStringTest)
 
     testOk1(epicsStrnCaseCmp(empty, "", 0) == 0);
     testOk1(epicsStrnCaseCmp(empty, "", 1) == 0);
-    testOk1(epicsStrnCaseCmp(space, empty, 1) < 0);
-    testOk1(epicsStrnCaseCmp(empty, space, 1) > 0);
+    testOk1(epicsStrnCaseCmp(space, empty, 1) > 0);
+    testOk1(epicsStrnCaseCmp(empty, space, 1) < 0);
     testOk1(epicsStrnCaseCmp(a, A, 1) == 0);
     testOk1(epicsStrnCaseCmp(a, A, 2) == 0);
     testOk1(epicsStrnCaseCmp(abcd, ABCD, 2) == 0);
@@ -65,17 +65,17 @@ MAIN(epicsStringTest)
     testOk1(epicsStrnCaseCmp(abcd, ABCD, 1000) == 0);
     testOk1(epicsStrnCaseCmp(abcd, ABCDE, 2) == 0);
     testOk1(epicsStrnCaseCmp(abcd, ABCDE, 4) == 0);
-    testOk1(epicsStrnCaseCmp(abcd, ABCDE, 1000)> 0);
+    testOk1(epicsStrnCaseCmp(abcd, ABCDE, 1000) < 0);
     testOk1(epicsStrnCaseCmp(abcde, ABCD, 2) == 0);
     testOk1(epicsStrnCaseCmp(abcde, ABCD, 4) == 0);
-    testOk1(epicsStrnCaseCmp(abcde, ABCD, 1000) < 0);
+    testOk1(epicsStrnCaseCmp(abcde, ABCD, 1000) > 0);
 
     testOk1(epicsStrCaseCmp(empty, "") == 0);
     testOk1(epicsStrCaseCmp(a, A) == 0);
     testOk1(epicsStrCaseCmp(abcd, ABCD) == 0);
-    testOk1(epicsStrCaseCmp(abcd, ABCDE) != 0);
-    testOk1(epicsStrCaseCmp(abcde, ABCD) != 0);
-    testOk1(epicsStrCaseCmp(abcde, "ABCDF") != 0);
+    testOk1(epicsStrCaseCmp(abcd, ABCDE) < 0);
+    testOk1(epicsStrCaseCmp(abcde, ABCD) > 0);
+    testOk1(epicsStrCaseCmp(abcde, "ABCDF") < 0);
 
     s = epicsStrDup(abcd);
     testOk(strcmp(s, abcd) == 0 && s != abcd, "epicsStrDup");
